# 简介
总所周知，虚拟DOM的比较算法发展史可谓是坎坷不平，从最简朴的DFS，到virtual-dom开源库那可怕且混乱的算法逻辑，再到cito.js的双端比较算法的横空出世，至此奠定了虚拟DOM的双端算法比较基础，后续几乎所有的虚拟DOM优化技术都是基于此。

这里重点比较几个开源库之间虚拟DOM中diff算法的不同的实现方式

## 虚拟DOM的核心思想

在创建一个真实的DOM节点前，先用一个非常简单的VNode节点来表示真实的DOM节点，只有VNode节点发生变化时，对应的真实DOM才发生改变，以此来达到性能提升。

虚拟DOM的几个优化点：
1. 不直接更新DOM，而是比较虚拟DOM，将需要变更的DOM节点更新出去
2. 为懒加载提供更多可能

误区：
1. 虚拟DOM不是完美的性能优化，而是性能平衡的结果，有时候直接操作DOM节点更优，虚拟DOM在框架级别上基本是最优的渲染DOM的方案
2. 虚拟DOM牺牲了内存来换取时间性能提升

# Diff比较算法

记住一点：核心思想不变即可，至于实现大同小异，不同的框架和开源库都会不同，跟业务和所使用的场景会有关系，比如临死不屈的`virtual-dom开源库`

## 原始的DFS算法

很明显，针对两颗树的比较，学过算法结构的大佬们基本都知道，一个深度优先搜索DFS即可强行遍历一波找出两颗树之间的差异，但是据著名xxxx大佬的算法来看，最优解也就能优化到`O(n^3)`的时间复杂度。

然而这么大的复杂度在前端这种面向用户视觉，基本全靠用户体验的场景下是行不通的，没有哪一个用户能够承受一个页面从打开页面开始就一直菊花loading转。

至此大佬们就相处了一个绝顶聪明的方法，适当的抛弃掉一些比较，基本骚操作如下：

比较新旧两颗树，从root节点出发，只要发现新的和旧的节点有一点不一样，就直接将整个旧节点和它的子节点删掉，然后将新的节点插入进去取代旧节点。

往往我们改变页面上的一项数据时，一般子节点都会发生变化，所以抛弃掉部分节点对我们的影响不大，因为早晚都会变化，即便是其中几个迭代没有发生变化，但是对我们影响不大。

经过上面的操作后，从之前的`O(n^3)`的时间复杂度就优化成了`O(n)`。

## virtual-dom开源库

该开源库并没有给出具体的比较思路，看代码去解析也是仁者见仁，智者见智，估计每个人都有不同的理解，所以以下仅代表我的个人看法。

`virtual-dom开源库`的基本实现思路：

一个DFS遍历主要的树节点，判断节点是否有变化，有变化就标记成功，这一点所有的虚拟DOM比较的算法都不变，属于比较算法的核心逻辑，唯一变化是对列表的优化处理。

一般的diff算法都对列表做了优化，使用key来优化区分，当出现相同key的时候会造成性能偏低，因为diff无法区分两个重复的key之间有何差异，一般会当作一个没有key的情况来处理，virtual-dom当前并没有考虑重复key的问题，所以我们只讨论没有重复key的情况。

大概思路是：将旧列表变成新列表，通过添加删除操作，即便是替换移动位置，也是通过删除和添加操作来完成，唯一特殊处理的场景是，两个相邻元素之间的位置交换(该逻辑可以尽可能减少dom操作)，如下：

```
第一种情况
a = [1, 2]
b = [2, 1]

假设a为旧列表，b为新列表，那么a变成b，只需要将2插入到a[0]位置，同时删除掉a[1]位置的数据即可：
a[1, 2] -> a[2, 1, 2] -> a[2, 1]，其中使用了一次removeChild和一次insertBefore

第二种情况
a = [2, 1]
b = [1, 0, 2]
假设a为旧列表，b为新列表，那么a变成b，只需要进行如下操作即可
a[2, 1] -> a[1] -> a[1, 0] -> a[1, 0, 2] 进行了一次removeChild，和两次insertBefore操作

```

具体的内容，请看virtual-dom.js代码注释，需要注意virtual-dom开源库并没有最优处理列表，只能说按照正常逻辑去处理复用的列表。其中使用了map来快速记录历史key的位置，该操作可以将原本双循环查找的`O(n^2)`性能优化成`O(n)`

## cito.js