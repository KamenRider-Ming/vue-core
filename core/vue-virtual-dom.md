# 简介
总所周知，虚拟DOM的比较算法发展史可谓是坎坷不平，从最简朴的DFS，到virtual-dom开源库那可怕且混乱的算法逻辑，再到cito.js的双端比较算法的横空出世，至此奠定了虚拟DOM的双端算法比较基础，后续几乎所有的虚拟DOM优化技术都是基于此。

这里重点比较几个开源库之间虚拟DOM中diff算法的不同的实现方式

## 虚拟DOM的核心思想

在创建一个真实的DOM节点前，先用一个非常简单的VNode节点来表示真实的DOM节点，只有VNode节点发生变化时，对应的真实DOM才发生改变，以此来达到性能提升。

虚拟DOM的几个优化点：
1. 不直接更新DOM，而是比较虚拟DOM，将需要变更的DOM节点更新出去
2. 为懒加载提供更多可能

误区：
1. 虚拟DOM不是完美的性能优化，而是性能平衡的结果，有时候直接操作DOM节点更优，虚拟DOM在框架级别上基本是最优的渲染DOM的方案
2. 虚拟DOM牺牲了内存来换取时间性能提升

# Diff比较算法

记住一点：核心思想不变即可，至于实现大同小异，不同的框架和开源库都会不同，跟业务和所使用的场景会有关系，比如临死不屈的`virtual-dom开源库`

## 原始的DFS算法

很明显，针对两颗树的比较，学过算法结构的大佬们基本都知道，一个深度优先搜索DFS即可强行遍历一波找出两颗树之间的差异，但是据著名xxxx大佬的算法来看，最优解也就能优化到`O(n^3)`的时间复杂度。

然而这么大的复杂度在前端这种面向用户视觉，基本全靠用户体验的场景下是行不通的，没有哪一个用户能够承受一个页面从打开页面开始就一直菊花loading转。

至此大佬们就相处了一个绝顶聪明的方法，适当的抛弃掉一些比较，基本骚操作如下：

比较新旧两颗树，从root节点出发，只要发现新的和旧的节点有一点不一样，就直接将整个旧节点和它的子节点删掉，然后将新的节点插入进去取代旧节点。

往往我们改变页面上的一项数据时，一般子节点都会发生变化，所以抛弃掉部分节点对我们的影响不大，因为早晚都会变化，即便是其中几个迭代没有发生变化，但是对我们影响不大。

经过上面的操作后，从之前的`O(n^3)`的时间复杂度就优化成了`O(n)`。

## virtual-dom开源库

该开源库并没有给出具体的比较思路，看代码去解析也是仁者见仁，智者见智，估计每个人都有不同的理解，所以以下仅代表我的个人看法。

`virtual-dom开源库`的基本实现思路：

一个DFS遍历主要的树节点，判断节点是否有变化，有变化就标记成功，这一点所有的虚拟DOM比较的算法都不变，属于比较算法的核心逻辑，唯一变化是对列表的优化处理。

一般的diff算法都对列表做了优化，使用key来优化区分，当出现相同key的时候会造成性能偏低，因为diff无法区分两个重复的key之间有何差异，一般会当作一个没有key的情况来处理，virtual-dom当前并没有考虑重复key的问题，所以我们只讨论没有重复key的情况。

大概思路是：将旧列表变成新列表，通过添加删除操作，即便是替换移动位置，也是通过删除和添加操作来完成，唯一特殊处理的场景是，两个相邻元素之间的位置交换(该逻辑可以尽可能减少dom操作)，如下：

```
第一种情况
a = [1, 2]
b = [2, 1]

假设a为旧列表，b为新列表，那么a变成b，只需要将2插入到a[0]位置，同时删除掉a[1]位置的数据即可：
a[1, 2] -> a[2, 1, 2] -> a[2, 1]，其中使用了一次removeChild和一次insertBefore

第二种情况
a = [2, 1]
b = [1, 0, 2]
假设a为旧列表，b为新列表，那么a变成b，只需要进行如下操作即可
a[2, 1] -> a[1] -> a[1, 0] -> a[1, 0, 2] 进行了一次removeChild，和两次insertBefore操作

```

具体的内容，请看virtual-dom.js代码注释，需要注意virtual-dom开源库并没有最优处理列表，只能说按照正常逻辑去处理复用的列表。其中使用了map来快速记录历史key的位置，该操作可以将原本双循环查找的`O(n^2)`性能优化成`O(n)`

## cito.js

该开源库首次使用双端比较算法，准确的来说只是在对连续首尾出现相同key的逻辑时，这个双端比较算法才有意义，当出现不一致时，直接跳出了双端比较算法的循环，然后的流程跟virtual-dom开源库的操作一样，由于citojs个人认为比较逻辑并没有准确良好的运用双端比较算法，感觉在citojs只是作为一种简单的优化项（当然即便是简单的优化项，但放大到DOM操作层面上，性能提升依旧是客观的），并不是核心内容，所以此处并不详解，具体可以看其updateChildren函数的实现，逻辑上并不复杂，比virtual-dom开源库更加容易让人理解，毕竟virtual-dom开源库的比较算法逻辑，个人认为有点让人容易懵逼。

## kivi.js

该开源库的作者总结了citojs的算法经验，同时在源码中对其使用的算法逻辑做了非常详细的解释，让我真正了解到了双端比较算法，与virtual-dom不同，kivi并不是将更新节点放到一个数组里面一起执行的，而是发现了变化直接就操作了DOM节点。

1. 针对完全没有key的列表处理，整体处理很简单，只对出现同一个元素的数据直接忽略，其他元素都采用替换操作。

```
使用头尾两个指针，不断缩减新旧列表比较范围。
只要是相同位置的元素相等则直接直接忽略，如果不相同则直接替换。
新列表多余的则插入，旧列表多余部分做删除操作。
硬要用算法来称呼的话，应该是双端比较+单端比较

初始状态下新旧列表以及此时的node列表情况：
A: -> [a a c d e g g] <-
B: -> [a a f d c g] <-
nodeList: [a a c d e g g]

直接忽略掉头尾相同的数据[a a g]三个节点，nodeList无变化
A: -> [c d e g] <-
B: -> [f d c] <-
nodeList: [a a c d e g g]

发现c和f不一样，直接用新列表中的f替换旧列表中的c，nodeList同时发生对应的变化
A: -> [d e g] <-
B: -> [d c] <-
nodeList: [a a f d e g g]
               ^(replace)

新旧列表中d元素一致，直接忽略，nodeList无变化
A: -> [e g] <-
B: -> [c] <-
nodeList: [a a f d e g g]

发现e和c不一样，直接用新列表中的c替换旧列表中的e，nodeList同时发生对应的变化
A: -> [g] <-
B: -> [] <-
nodeList: [a a f d c g g]
                   ^(replace)

发现旧列表多出来一个g元素，则直接删除该节点，同时nodeList同时发生对应的变化
A: -> [] <-
B: -> [] <-
nodeList: [a a f d c g g]
                     ^(remove)

到此列表比较替换完成，node节点与新列表b的数据保持一致
final nodeList: [a a f d c g]
```

1. 针对有key的列表节点，则是先使用双端比较算法过滤掉一部分可以使用一个插入操作就可以将他们的位置从旧列表调整新列表的key节点，然后使用最长上升子序列（用他们在新列表的下标位置）来确认不需要调整的节点，接着将需要调整的节点移动到对应的上升子序列中对应的位置

```

流程分为两部走，一个是走双端比较算法，一个是走最长上升子序列

## 第一步：双端比较算法

初始状态下新旧列表以及此时的node列表情况：
A: -> [a b c d e f g] <-
B: -> [a b f d c g] <-
nodeList: [a b c d e f g]

分别用头尾指针比较，发现a,b和g位置都没啥子变化，直接忽略
A: -> [c d e f] <-
             ^
B: -> [f d c] <-
       ^
nodeList: [a b c d e f g]

接着发现新列表的f在开头，旧列表f的末尾，则直接旧列表的f插入到旧列表的开头，nodeList对应发生变化
A: -> [f c d e] <-
B: -> [f d c] <-
nodeList: [a b f c d e g]

此时f相同位置元素相同，直接忽略
A: -> [c d e] <-
       ^
B: -> [d c] <-
         ^
nodeList: [a b f c d e g]

接着发现新列表的c在末尾，旧列表c的开头，则直接旧列表的c插入到旧列表的末尾即可，nodeList对应发生变化
A: -> [d e c] <-
B: -> [d c] <-
nodeList: [a b f d e c g]

此时c和d相同位置元素相同，直接忽略
A: -> [e] <-
B: -> [] <-
nodeList: [a b f d e c g]

发现e是多出来的元素则直接性删除操作
A: -> [e] <-
B: -> [] <-
nodeList: [a b f d e c g]
                   ^(remove)

到此比较逻辑完成
nodeList: [a b f d c g] 与新列表元素保持一致

## 第二步：最长上升子序列


```